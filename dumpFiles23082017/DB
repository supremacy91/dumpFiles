https://habrahabr.ru/post/255361/ хороший справочник
http://phpfaq.ru/mysql/sql_injection - sql иньекции


СУБД – Система Управления этими Базами Данных, т.е. это комплекс инструментов для работы с конкретным типом БД (MS SQL, Oracle, MySQL, Firebird, PostgreSQL, …). Т.к. в жизни, в разговорной речи, мы по большей части говорим: «БД Oracle», или даже просто «Oracle», на самом деле подразумевая «СУБД Oracle»

DML – Data Manipulation Language (язык манипулирования данными), который содержит следующие конструкции:

    SELECT – выборка данных
    INSERT – вставка новых данных
    UPDATE – обновление данных
    DELETE – удаление данных
    MERGE – слияние данных

TRUNCATE TABLE Employees просто чистит таблицу Employees

explain <SQL query> - выводит информацию об оптимизации запроса
------------------------------------------------------------------------------------------------------------

Простую базу данных (без указания дополнительных параметров) можно создать, выполнив следующую команду:
CREATE DATABASE Test

Удалить базу данных можно командой (стоит быть очень осторожным с данной командой):
DROP DATABASE Test

Для того, чтобы переключиться на нашу базу данных, можно выполнить команду:
USE Test

Для уже существующей таблицы поля можно переопределить при помощи следующих команд:
-- обновление поля ID
ALTER TABLE Employees ALTER COLUMN ID int NOT NULL

-- обновление поля Name
ALTER TABLE Employees ALTER COLUMN Name nvarchar(30) NOT NULL

-- обновление полей ID и Name (здесь вместо ALTER COLUMN используется MODIFY(…))
ALTER TABLE Employees MODIFY(ID int NOT NULL,Name nvarchar2(30) NOT NULL);

-- добавление PK (в данном случае конструкция выглядит как и в MS SQL, она будет показана ниже)
ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY(ID);

пример
CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30) NOT NULL,
  Birthday date,
  Email nvarchar(30),
  Position nvarchar(30),
  Department nvarchar(30)
)

Если требуется наоборот сделать существующий столбец необязательным для заполнения, то используем следующий синтаксис команды:
ALTER TABLE Employees ALTER COLUMN Name nvarchar(30) NULL
Или просто:
ALTER TABLE Employees ALTER COLUMN Name nvarchar(30)
Так же данной командой мы можем изменить тип поля на другой совместимый тип, или же изменить его длину. Для примера давайте расширим поле Name до 50 символов:
ALTER TABLE Employees ALTER COLUMN Name nvarchar(50)



------------------------------------------------------------------------------------------------------------

UPDATE

    UPDATE <имя таблицы>
    SET {<имя столбца> = {<выражение для вычисления значения столбца>
    | NULL
    | DEFAULT},...}
    [ {WHERE <предикат>}]

------------------------------------------------------------------------------------------------------------

задание псевдонимов (alias)

SELECT emp.ID,emp.Name
FROM Employees AS emp 
SELECT emp.ID,emp.Name
FROM Employees emp -- ключевое слово AS можно отпустить

Задание псевдонимов для столбцов запроса

SELECT
  -- даем имя вычисляемому столбцу
  LastName+' '+FirstName+' '+MiddleName AS ФИО,
  -- использование двойных кавычек, т.к. используется пробел
  HireDate AS "Дата приема",
  -- использование квадратных скобок, т.к. используется пробел
  Birthday AS [Дата рождения],
  -- слово AS не обязательно
  Salary ZP
FROM Employees

------------------------------------------------------------------------------------------------------------

После имя поля в предложении ORDER BY можно задать опцию DESC, которая служит для сортировки этого поля в порядке убывания:

SELECT LastName,FirstName,Salary
FROM Employees
ORDER BY -- упорядочить в порядке
  Salary DESC, -- 1. убывания Заработной Платы
  LastName, -- 2. по Фамилии (ASC по умолчанию)
  FirstName -- 3. по Имени (ASC по умолчанию)

------------------------------------------------------------------------------------------------------------

TOP

TOP – ограничивает число строк, возвращаемых в результирующем наборе запроса до заданного числа или процентного значения. Если предложение TOP используется совместно с предложением ORDER BY, то результирующий набор ограничен первыми N строками отсортированного результата. В противном случае возвращаются первые N строк в неопределенном порядке.

ернуть нам только первые 10 строк, но для наглядности мы скажем только 2:
SELECT TOP 2
  *
FROM Employees

Так же можно указать слово PERCENT, для того чтобы вернулось соответствуй процент строк из результирующего набора:
SELECT TOP 25 PERCENT
  *
FROM Employees

------------------------------------------------------------------------------------------------------------

PRIMARY KEY

Если первичный ключ в таблице состоит только из значений одного столбца, то можно использовать следующий синтаксис:
CREATE TABLE Employees(
  ID int NOT NULL CONSTRAINT PK_Employees PRIMARY KEY, -- указываем как характеристику поля
  Name nvarchar(30) NOT NULL,
  Birthday date,
  Email nvarchar(30),
  Position nvarchar(30),
  Department nvarchar(30)
)

Создать первичный ключ к уже существующей таблице можно при помощи команды:
ALTER TABLE Employees ADD CONSTRAINT PK_Employees PRIMARY KEY(ID)

Где «PK_Employees» это имя ограничения, отвечающего за первичный ключ. Обычно для наименования первичного ключа используется префикс «PK_» после которого идет имя таблицы.
Если первичный ключ состоит из нескольких полей, то эти поля необходимо перечислить в скобках через запятую:
ALTER TABLE имя_таблицы ADD CONSTRAINT имя_ограничения PRIMARY KEY(поле1,поле2,…)

На самом деле имя ограничения можно и не задавать, в этом случае ему будет присвоено системное имя (наподобие «PK__Employee__3214EC278DA42077»):

CREATE TABLE Employees(						
  ID int NOT NULL,
  Name nvarchar(30) NOT NULL,
  Birthday date,
  Email nvarchar(30),
  Position nvarchar(30),
  Department nvarchar(30),
  PRIMARY KEY(ID)
)
Или:
CREATE TABLE Employees(
  ID int NOT NULL PRIMARY KEY,
  Name nvarchar(30) NOT NULL,
  Birthday date,
  Email nvarchar(30),
  Position nvarchar(30),
  Department nvarchar(30)
)

Но я бы рекомендовал для постоянных таблиц всегда явно задавать имя ограничения, т.к. по явно заданному и понятному имени с ним впоследствии будет легче проводить манипуляции, например, можно произвести его удаление:

ALTER TABLE Employees DROP CONSTRAINT PK_Employees

------------------------------------------------------------------------------------------------------------

FOREIGN KEY
ALTER TABLE Employees ADD CONSTRAINT FK_Employees_PositionID
FOREIGN KEY(PositionID) REFERENCES Positions(ID)

Напоследок стоит сказать, что ссылочные ключи могут включать дополнительные опции ON DELETE CASCADE и ON UPDATE CASCADE, которые говорят о том, как вести себя при удалении или обновлении записи, на которую есть ссылки в таблице-справочнике. Если эти опции не указаны, то мы не можем изменить ID в таблице справочнике у той записи, на которую есть ссылки из другой таблицы, так же мы не сможем удалить такую запись из справочника, пока не удалим все строки, ссылающиеся на эту запись или, же обновим в этих строках ссылки на другое значение.


Для примера пересоздадим таблицу с указанием опции ON DELETE CASCADE для FK_Employees_DepartmentID:
DROP TABLE Employees

CREATE TABLE Employees(
  ID int NOT NULL,
  Name nvarchar(30),
  Birthday date,
  Email nvarchar(30),
  PositionID int,
  DepartmentID int,
  ManagerID int,
CONSTRAINT PK_Employees PRIMARY KEY (ID),
CONSTRAINT FK_Employees_DepartmentID FOREIGN KEY(DepartmentID) REFERENCES Departments(ID)
ON DELETE CASCADE,
CONSTRAINT FK_Employees_PositionID FOREIGN KEY(PositionID) REFERENCES Positions(ID),
CONSTRAINT FK_Employees_ManagerID FOREIGN KEY (ManagerID) REFERENCES Employees(ID)
)

INSERT Employees (ID,Name,Birthday,PositionID,DepartmentID,ManagerID)VALUES
(1000,N'Иванов И.И.','19550219',2,1,NULL),
(1001,N'Петров П.П.','19831203',3,3,1003),
(1002,N'Сидоров С.С.','19760607',1,2,1000),
(1003,N'Андреев А.А.','19820417',4,3,1000)

Удалим отдел с идентификатором 3 из таблицы Departments:

DELETE Departments WHERE ID=3
Как видим, данные по отделу 3 из таблицы Employees так же удалились.

Опция ON UPDATE CASCADE ведет себя аналогично, но действует она при обновлении значения ID в справочнике. Например, если мы поменяем ID должности в справочнике должностей, то в этом случае будет производиться обновление DepartmentID в таблице Employees на новое значение ID которое мы задали в справочнике. Но в данном случае это продемонстрировать просто не получится, т.к. у колонки ID в таблице Departments стоит опция IDENTITY, которая не позволит нам выполнить следующий запрос (сменить идентификатор отдела 3 на 30):

UPDATE Departments
SET
  ID=30
WHERE ID=3

------------------------------------------------------------------------------------------------------------

Active record (AR) — шаблон проектирования приложений следующего приницпа:

Пусть существует таблица в базе данных. Для данной таблицы создаётся специальный класс AR, являющийся отражением (представлением) таблицы, таким образом, что:
    каждый экземпляр данного класса соответствует одной записи таблицы;
    при создании нового экземпляра класса (и заполнении соответствующих полей) в таблицу добавляется новая запись;
    при чтении полей объекта считываются соответствующие значения записи таблицы баз данных;
    при изменении (удалении) какого-либо объекта изменяется (удаляется) соответствующая ему запись.

PDO  — простой интерфейс для работы с базой данных, который предоставляет одинаковые методы для работы с различными базами данными, поэтому вам не надо задумываться с какой именно БД мы работаем в текущий момент.

ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». Существуют как проприетарные, так и свободные реализации этой технологии.

EAV сущности(Advanced ORM) - частный случай ORM

------------------------------------------------------------------------------------------------------------

EAV

Для хранения данных в БД нам понадобиться всего три таблицы, а именно:

    EAV_ENTITY – таблица описывающая сущности.</li>
    EAV_ATTR_NAME – таблица описывающая атрибуты сущностей</li>
    EAV_ATTR_VALUE - таблица, содержащая значения атрибутов.</li>

Соответственно их поля:
EAV_ENTITY:

    id
    name – имя сущности
    nattr – число атрибутов сущности
    description – описание сущности

EAV_ATTR_NAME:

    id
    entity_id – идентификатор сущности, которой принадлежит атрибут (ВК)
    name – имя атрибута

EAV_ATTR_VALUE:

    id
    def_id – внешний ключ на таблицу EAV_ATTR_NAME, указывающий имя атрибут и его принадлежность к сущности (ВК)
    value – значение атрибута.</li>
    instance_id - идентификатор экземпляра сущности, владеющий значением атрибута.

------------------------------------------------------------------------------------------------------------




